+++
title = '刨析设计模式（更新中）'

date = 2025-03-16T13:30:01+08:00

categories = ["设计模式"]

tags = ["设计模式"]

+++



#### 刨析设计模式



##### 设计模式类型

###### 创建型模式

创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性。

- 工厂模式
- 抽象工厂模式
- 单例模式
- 建造者模式
- 原型模式

###### 结构型模式

结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。

- 适配器模式
- 桥接模式
- 组合模式
- 装饰模式
- 外观模式
- 享元模式
- 代理模式

###### 行为型模式

行为模式负责对象间的高效沟通和职责委派。

- 责任链模式
- 命令模式
- 迭代器模式
- 中介者模式
- 备忘录模式
- 观察者模式
- 状态模式
- 策略模式
- 模板方法模式
- 访问者模式



---





##### 工厂模式

工厂模式是一种创建型设计模式，用于封装对象的创建过程，使代码更具灵活性和可维护性。它通过定义一个创建对象的接口，让子类决定实例化哪个类，从而将对象的创建与使用分离。



![工厂模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg)



###### 简单工厂模式

- 通过一个工厂类根据传入的参数决定创建哪种产品对象。
- 优点：结构简单，易于实现。
- 缺点：不符合开闭原则，新增产品类型需修改工厂类。

```java
package com.yiwyn.factory;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

public class SimpleFactoryDemo {

    public static void main(String[] args) {
        Shape square = ShapeFactory.getShape("square");
        System.out.println(square.draw());
    }

    /**
     * 图形工厂类
     */
    static class ShapeFactory {
        public static Shape getShape(String shapeType) {
            if (shapeType.equalsIgnoreCase("square")) {
                return new Square("square");
            } else if (shapeType.equalsIgnoreCase("triangle")) {
                return new Triangle("triangle");
            }
            return null;
        }
    }


    /**
     * 基本图形
     */
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    static class Shape {
        private String name;
        public String draw() {
            return name;
        }
    }

    /**
     * 正方形
     */
    @Data
    @EqualsAndHashCode(callSuper = true)
    static class Square extends Shape {
        public Square(String name) {
            super(name);
        }
    }

    /**
     * 三角形
     */
    @Data
    @EqualsAndHashCode(callSuper = true)
    static class Triangle extends Shape {
        public Triangle(String name) {
            super(name);
        }
    }
}

```



###### 工厂方法模式

- 定义一个创建对象的接口，由子类决定实例化哪个类。
- 优点：符合开闭原则，扩展性强。
- 缺点：每增加一个产品类，就需要增加一个对应的工厂类，导致类数量增加。

```java
package com.yiwyn.factory;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

public class FactoryMethodDemo {

    public static void main(String[] args) {

        /*画正方形*/
        IShapeFactory shapeFactory = new SquareFactory();
        Shape shape = shapeFactory.createShape();
        shape.draw();

        /*随机大小的三角形*/
        shapeFactory = new TriangleFactory();
        shape = shapeFactory.createRandomSizeShape();
        shape.draw();
    }

    /**
     * 图形工厂类
     */
    interface IShapeFactory {
        Shape createShape();

        Shape createRandomSizeShape();
    }

    static class SquareFactory implements IShapeFactory {

        @Override
        public Shape createShape() {
            return new Square("正方形");
        }

        @Override
        public Shape createRandomSizeShape() {
            return new Square("随机大小的正方形");
        }
    }

    static class TriangleFactory implements IShapeFactory {

        @Override
        public Shape createShape() {
            return new Triangle("三角形");
        }

        @Override
        public Shape createRandomSizeShape() {
            return new Triangle("随机大小的三角形");
        }
    }


    /**
     * 基本图形
     */
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    static class Shape {
        private String name;

        public void draw() {
            System.out.println(name);
        }
    }

    /**
     * 正方形
     */
    @Data
    @EqualsAndHashCode(callSuper = true)
    static class Square extends Shape {
        public Square(String name) {
            super(name);
        }
    }

    /**
     * 三角形
     */
    @Data
    @EqualsAndHashCode(callSuper = true)
    static class Triangle extends Shape {
        public Triangle(String name) {
            super(name);
        }
    }


}

```



###### 抽象工厂模式

![抽象工厂模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg)

- 提供一个创建一系列相关或依赖对象的接口，无需指定具体类。
- 优点：能创建多个相关对象，保持一致性。
- 缺点：扩展复杂，新增产品族或产品等级结构需修改抽象工厂接口及其实现类。

```java
package com.yiwyn.factory;

/**
 * 抽象工厂demo
 */
public class AbstractFactoryDemo {

    public static void main(String[] args) {

        DeviceAbstractFactory factory = new AppleDeviceFactory();
        Phone phone = factory.createPhone();
        Laptap laptap = factory.createLaptap();
        phone.call();
        laptap.work();
    }


    /**
     * 手机
     */
    interface Phone {
        void call();
    }

    /**
     * 笔记本
     */
    interface Laptap {
        void work();
    }


    /**
     * 设备抽象工厂
     */
    interface DeviceAbstractFactory {

        Phone createPhone();

        Laptap createLaptap();
    }


    static class HuaweiPhone implements Phone {
        @Override
        public void call() {
            System.out.println("华为手机");
        }
    }

    static class IPhone implements Phone {

        @Override
        public void call() {
            System.out.println("苹果手机");
        }
    }


    static class HauweiLaptap implements Laptap {
        @Override
        public void work() {
            System.out.println("华为笔记本工作");
        }
    }

    static class MacBookLaptap implements Laptap {

        @Override
        public void work() {
            System.out.println("苹果笔记本");
        }
    }

    /**
     * 华为设备工厂
     */
    static class HuaweiDeviceFacotry implements DeviceAbstractFactory {

        @Override
        public Phone createPhone() {
            return new HuaweiPhone();
        }

        @Override
        public Laptap createLaptap() {
            return new HauweiLaptap();
        }
    }

    /**
     * 苹果设备工厂
     */
    static class AppleDeviceFactory implements DeviceAbstractFactory {

        @Override
        public Phone createPhone() {
            return new IPhone();
        }

        @Override
        public Laptap createLaptap() {
            return new MacBookLaptap();
        }
    }
}

```



---



##### 策略模式

策略模式是一种行为型设计模式，它定义了一系列算法或行为，并将它们封装在独立的类中，使得它们可以互相替换。策略模式让算法的变化独立于使用它的客户端，从而提高了代码的灵活性和可维护性。



![策略模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg)



###### 核心思想

1. 将算法或行为抽象为接口：
   - 定义一个策略接口，所有具体策略类都实现这个接口。
2. 封装具体策略：
   - 每个具体策略类实现策略接口，提供具体的算法或行为。
3. 客户端使用策略：
   - 客户端持有一个策略接口的引用，可以在运行时动态切换具体策略。

```java
package com.yiwyn.strategy;

import java.util.HashMap;
import java.util.Map;

public class StrategyDemo {

    public static void main(String[] args) {
        PayContext payContext = new PayContext();
        payContext.pay();
    }

    /**
     * 支付服务Context
     */
    static class PayContext {
        /**
         * 这里payService层直接调用了底层逻辑，若逻辑
         */
        public void pay() {
            IPayStrategy pay = AppConfig.getPay();
            pay.pay();
        }
    }

    /**
     * 模拟系统配置
     */
    static class AppConfig {
        // 读取系统配置
        private static final String payChannel = System.getProperty("payChannel", "AliPay");
        // 支付信息实现
        private static final Map<String, IPayStrategy> payMap = new HashMap<>();

        static {
            payMap.put("AliPay", new AliIPayStrategy());
            payMap.put("WxPay", new WxIPayStrategy());
        }

        public static IPayStrategy getPay() {
            return payMap.get(payChannel);
        }
    }

    /**
     * 支付接口
     */
    interface IPayStrategy {
        void pay();
    }


    /**
     * 阿里支付策略
     */
    static class AliIPayStrategy implements IPayStrategy {

        @Override
        public void pay() {
            System.out.println("阿里支付");
        }
    }

    /**
     * 微信支付策略
     */
    static class WxIPayStrategy implements IPayStrategy {

        @Override
        public void pay() {
            System.out.println("微信支付");
        }
    }
}

```



##### 单例模式





---



##### 适配器模式

适配器模式是一种结构型设计模式，它允许不兼容的接口之间进行协作。适配器模式通过将一个类的接口转换成客户端期望的另一个接口，使得原本由于接口不兼容而无法一起工作的类可以协同工作。



![适配器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20210223-adapter.png)



###### 核心思想

1. 接口转换：
   - 适配器模式通过一个适配器类，将目标接口转换为客户端期望的接口。
2. 解耦：
   - 客户端与目标类之间解耦，客户端只需要依赖目标接口，而无需关心具体实现。
3. 复用：
   - 适配器模式可以复用现有的类，而无需修改其代码。



```java
package com.yiwyn.adapter;

public class Main {
    public static void main(String[] args) {

        Mobile mobile = new Mobile();

        Power220V power220V = new Power220V();
        Power5V power5V = new PowerAdapter(power220V);

        mobile.inputPower(power5V);
    }


    /**
     * 手机
     */
    static class Mobile {

        public void inputPower(Power5V power5V) {
            int i = power5V.provider5VPower();
            System.out.println("充电电压=" + i);
        }
    }

    /**
     * 5v接口
     */
    public interface Power5V {
        int provider5VPower();
    }

    /**
     * 220v接口
     */
    static class Power220V {
        public int provider220VPower() {
            return 220;
        }
    }


    // 电源适配
    static class PowerAdapter implements Power5V {

        private final Power220V power220V;

        public PowerAdapter(Power220V power220V) {
            this.power220V = power220V;
        }

        @Override
        public int provider5VPower() {
            int v220 = this.power220V.provider220VPower();
            return v220 - 215;
        }
    }

}
```

