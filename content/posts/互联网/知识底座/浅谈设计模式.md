+++
title = '浅谈设计模式（更新中）'

date = 2025-03-16T13:30:01+08:00

categories = ["设计模式"]

tags = ["设计模式"]

+++



### 浅谈设计模式



#### 如何理解设计模式&理性看待设计模式



##### 理性看待设计模式

首先可以肯定的是，单独的进行设计模式的学习是非常的<font color='red'>晦涩难懂</font>的。

我们大概都知道在软件工程中，我们在软件设计中，要考虑各种<font color='red'>质量属性</font>（可修改性、可扩展性、可测试性等），简单来看就是【容易扩展、容易应对变化】，这其实是一门艺术。

我们在学习设计模式的时候，往往都是只看到了最终的艺术，忽略了走向艺术的过程。因为缺少过程，我们对设计模式的学习和理解就上升了非常高的难度。

在很多时候，好的代码是迭代的出来的，是重构得到的。这一步是学习、理解设计模式的最关键的地方。



##### 设计原则与设计模式的关系

设计原则是“道”，设计模式是“术”。所以又回到了设计原则，希望大家可以在学习设计模式之前，先理解设计原则。



##### 什么是设计模式

设计模式是四人帮（GoF）写的一本叫《Design Patterns》的书中提出来的，这本书里面总结了23种设计模式，也是**「最常用的设计模式」**。

所以设计模式其实并不止23种，只是因为这23种是比较常用的设计模式，它们分别适用于不同的场景，也覆盖了绝大多数软件设计的场景。这23种设计模式只是前人的“经验总结”或者“套路”，有时候经验还是蛮重要的，使用这些经验能够少走很多弯路。

有时候多种设计模式可以互相配合起来使用，或者在现有的23种设计模式之上有一些变化，甚至是总结出一些新的“套路”，用来解决现有23种设计模式不能解决的问题，都是正常的。<font color='red'>设计模式并不是死的，一成不变的，它应该是灵活的</font>。



---



#### 设计模式类型

###### 创建型模式

创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性。

- 工厂模式
- 抽象工厂模式
- 单例模式
- 建造者模式
- 原型模式

###### 结构型模式

结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。

- 适配器模式
- 桥接模式
- 组合模式
- 装饰模式
- 外观模式
- 享元模式
- 代理模式

###### 行为型模式

行为模式负责对象间的高效沟通和职责委派。

- 责任链模式
- 命令模式
- 迭代器模式
- 中介者模式
- 备忘录模式
- 观察者模式
- 状态模式
- 策略模式
- 模板方法模式
- 访问者模式



---





##### 工厂模式

工厂模式是一种创建型设计模式，用于封装对象的创建过程，使代码更具灵活性和可维护性。它通过定义一个创建对象的接口，让子类决定实例化哪个类，从而将对象的创建与使用分离。





![工厂模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg)



###### 简单工厂模式（并非是一种单独的设计模式，而是工厂模式的基础）

- 通过一个工厂类根据传入的参数决定创建哪种产品对象。
- 优点：结构简单，易于实现。
- 缺点：不符合开闭原则，新增产品类型需修改工厂类。

```java
package com.yiwyn.factory;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

public class SimpleFactoryDemo {

    public static void main(String[] args) {
        Shape square = ShapeFactory.getShape("square");
        System.out.println(square.draw());
    }

    /**
     * 图形工厂类
     */
    static class ShapeFactory {
        public static Shape getShape(String shapeType) {
            if (shapeType.equalsIgnoreCase("square")) {
                return new Square("square");
            } else if (shapeType.equalsIgnoreCase("triangle")) {
                return new Triangle("triangle");
            }
            return null;
        }
    }


    /**
     * 基本图形
     */
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    static class Shape {
        private String name;
        public String draw() {
            return name;
        }
    }

    /**
     * 正方形
     */
    @Data
    @EqualsAndHashCode(callSuper = true)
    static class Square extends Shape {
        public Square(String name) {
            super(name);
        }
    }

    /**
     * 三角形
     */
    @Data
    @EqualsAndHashCode(callSuper = true)
    static class Triangle extends Shape {
        public Triangle(String name) {
            super(name);
        }
    }
}

```



###### 工厂方法模式

- 定义一个创建对象的接口，由子类决定实例化哪个类。
- 优点：符合开闭原则，扩展性强。
- 缺点：每增加一个产品类，就需要增加一个对应的工厂类，导致类数量增加。

```java
package com.yiwyn.factory;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

public class FactoryMethodDemo {

    public static void main(String[] args) {

        /*画正方形*/
        IShapeFactory shapeFactory = new SquareFactory();
        Shape shape = shapeFactory.createShape();
        shape.draw();

        /*随机大小的三角形*/
        shapeFactory = new TriangleFactory();
        shape = shapeFactory.createRandomSizeShape();
        shape.draw();
    }

    /**
     * 图形工厂类
     */
    interface IShapeFactory {
        Shape createShape();

        Shape createRandomSizeShape();
    }

    static class SquareFactory implements IShapeFactory {

        @Override
        public Shape createShape() {
            return new Square("正方形");
        }

        @Override
        public Shape createRandomSizeShape() {
            return new Square("随机大小的正方形");
        }
    }

    static class TriangleFactory implements IShapeFactory {

        @Override
        public Shape createShape() {
            return new Triangle("三角形");
        }

        @Override
        public Shape createRandomSizeShape() {
            return new Triangle("随机大小的三角形");
        }
    }


    /**
     * 基本图形
     */
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    static class Shape {
        private String name;

        public void draw() {
            System.out.println(name);
        }
    }

    /**
     * 正方形
     */
    @Data
    @EqualsAndHashCode(callSuper = true)
    static class Square extends Shape {
        public Square(String name) {
            super(name);
        }
    }

    /**
     * 三角形
     */
    @Data
    @EqualsAndHashCode(callSuper = true)
    static class Triangle extends Shape {
        public Triangle(String name) {
            super(name);
        }
    }


}

```



###### 抽象工厂模式

![抽象工厂模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg)

- 提供一个创建一系列相关或依赖对象的接口，无需指定具体类。
- 优点：能创建多个相关对象，保持一致性。
- 缺点：扩展复杂，新增产品族或产品等级结构需修改抽象工厂接口及其实现类。

```java
package com.yiwyn.factory;

/**
 * 抽象工厂demo
 */
public class AbstractFactoryDemo {

    public static void main(String[] args) {

        DeviceAbstractFactory factory = new AppleDeviceFactory();
        Phone phone = factory.createPhone();
        Laptap laptap = factory.createLaptap();
        phone.call();
        laptap.work();
    }


    /**
     * 手机
     */
    interface Phone {
        void call();
    }

    /**
     * 笔记本
     */
    interface Laptap {
        void work();
    }


    /**
     * 设备抽象工厂
     */
    interface DeviceAbstractFactory {

        Phone createPhone();

        Laptap createLaptap();
    }


    static class HuaweiPhone implements Phone {
        @Override
        public void call() {
            System.out.println("华为手机");
        }
    }

    static class IPhone implements Phone {

        @Override
        public void call() {
            System.out.println("苹果手机");
        }
    }


    static class HauweiLaptap implements Laptap {
        @Override
        public void work() {
            System.out.println("华为笔记本工作");
        }
    }

    static class MacBookLaptap implements Laptap {

        @Override
        public void work() {
            System.out.println("苹果笔记本");
        }
    }

    /**
     * 华为设备工厂
     */
    static class HuaweiDeviceFacotry implements DeviceAbstractFactory {

        @Override
        public Phone createPhone() {
            return new HuaweiPhone();
        }

        @Override
        public Laptap createLaptap() {
            return new HauweiLaptap();
        }
    }

    /**
     * 苹果设备工厂
     */
    static class AppleDeviceFactory implements DeviceAbstractFactory {

        @Override
        public Phone createPhone() {
            return new IPhone();
        }

        @Override
        public Laptap createLaptap() {
            return new MacBookLaptap();
        }
    }
}

```



---



##### 策略模式

策略模式是一种行为型设计模式，它定义了一系列算法或行为，并将它们封装在独立的类中，使得它们可以互相替换。策略模式让算法的变化独立于使用它的客户端，从而提高了代码的灵活性和可维护性。



![策略模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg)



###### 核心思想

1. 将算法或行为抽象为接口：
   - 定义一个策略接口，所有具体策略类都实现这个接口。
2. 封装具体策略：
   - 每个具体策略类实现策略接口，提供具体的算法或行为。
3. 客户端使用策略：
   - 客户端持有一个策略接口的引用，可以在运行时动态切换具体策略。

```java
package com.yiwyn.strategy;

import java.util.HashMap;
import java.util.Map;

public class StrategyDemo {

    public static void main(String[] args) {
        PayContext payContext = new PayContext();
        payContext.pay();
    }

    /**
     * 支付服务Context
     */
    static class PayContext {
        /**
         * 这里payService层直接调用了底层逻辑，若逻辑
         */
        public void pay() {
            IPayStrategy pay = AppConfig.getPay();
            pay.pay();
        }
    }

    /**
     * 模拟系统配置
     */
    static class AppConfig {
        // 读取系统配置
        private static final String payChannel = System.getProperty("payChannel", "AliPay");
        // 支付信息实现
        private static final Map<String, IPayStrategy> payMap = new HashMap<>();

        static {
            payMap.put("AliPay", new AliIPayStrategy());
            payMap.put("WxPay", new WxIPayStrategy());
        }

        public static IPayStrategy getPay() {
            return payMap.get(payChannel);
        }
    }

    /**
     * 支付接口
     */
    interface IPayStrategy {
        void pay();
    }


    /**
     * 阿里支付策略
     */
    static class AliIPayStrategy implements IPayStrategy {

        @Override
        public void pay() {
            System.out.println("阿里支付");
        }
    }

    /**
     * 微信支付策略
     */
    static class WxIPayStrategy implements IPayStrategy {

        @Override
        public void pay() {
            System.out.println("微信支付");
        }
    }
}

```



##### 单例模式

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。



###### 核心思想

- 确保一个类只有一个实例，并提供一个全局访问点来访问该实例。



```java
package com.yiwyn.singleton;


public class MyProperties {

    private static final MyProperties instance = new MyProperties();

    public static MyProperties getInstance() {
        return instance;
    }
    
    public void readProperties() {
        System.out.println("read properties ： test");
    }
}


package com.yiwyn.singleton;

public class SingletonDemo {

    public static void main(String[] args) {
        MyProperties.getInstance().readProperties();
    }
}
```



---



##### 适配器模式

适配器模式是一种结构型设计模式，它允许不兼容的接口之间进行协作。适配器模式通过将一个类的接口转换成客户端期望的另一个接口，使得原本由于接口不兼容而无法一起工作的类可以协同工作。



![image-20250317131151138](https://filestore.lifepoem.fun/know/202503171311238.png)



###### 核心思想

1. 接口转换：
   - 适配器模式通过一个适配器类，将目标接口转换为客户端期望的接口。
2. 解耦：
   - 客户端与目标类之间解耦，客户端只需要依赖目标接口，而无需关心具体实现。
3. 复用：
   - 适配器模式可以复用现有的类，而无需修改其代码。



```java
package com.yiwyn.adapter;

public class Main {
    public static void main(String[] args) {

        Mobile mobile = new Mobile();

        Power220V power220V = new Power220V();
        Power5V power5V = new PowerAdapter(power220V);

        mobile.inputPower(power5V);
    }


    /**
     * 手机
     */
    static class Mobile {

        public void inputPower(Power5V power5V) {
            int i = power5V.provider5VPower();
            System.out.println("充电电压=" + i);
        }
    }

    /**
     * 5v接口
     */
    public interface Power5V {
        int provider5VPower();
    }

    /**
     * 220v接口
     */
    static class Power220V {
        public int provider220VPower() {
            return 220;
        }
    }


    // 电源适配
    static class PowerAdapter implements Power5V {

        private final Power220V power220V;

        public PowerAdapter(Power220V power220V) {
            this.power220V = power220V;
        }

        @Override
        public int provider5VPower() {
            int v220 = this.power220V.provider220VPower();
            return v220 - 215;
        }
    }

}
```





---





##### 创建者模式





![img](https://i-blog.csdnimg.cn/img_convert/4acc3865b72864fbb821e452c0e4f957.png)



###### 核心思想

复杂对象的构建算法"与它的"部件及组装方式"分离，使得构件算法和组装方式可以独立应对变化



```java
package com.yiwyn.builder;

import lombok.Data;

import java.io.Serializable;

public class Builder01Demo {

    public static void main(String[] args) {
        PetBuilder petBuilder = new PetBuilder();
        petBuilder.buildPetAge(10).buildPetName("测试");
        Director director = new Director(petBuilder);
        Pet construct = director.construct();
        System.out.println(construct);
    }


    /**
     * 宠物类
     */
    @Data
    static class Pet implements Serializable {
        private static final long serialVersionUID = -2890296999914201365L;

        private String petName;
        private Integer petAge;

    }

    /**
     * 创建者接口
     */
    interface Builder {

        PetBuilder buildPetName(String petName);

        PetBuilder buildPetAge(Integer age);

        Pet createPet();
    }

    /**
     * 宠物创建者
     */
    static class PetBuilder implements Builder {

        private final Pet pet = new Pet();

        @Override
        public PetBuilder buildPetName(String petName) {
            pet.setPetName(petName);
            return this;
        }

        @Override
        public PetBuilder buildPetAge(Integer age) {
            pet.setPetAge(age);
            return this;
        }

        @Override
        public Pet createPet() {
            return pet;
        }
    }


    /**
     * 指挥者
     */
    static class Director {
        private final Builder builder;

        public Director(Builder builder) {
            this.builder = builder;
        }

        public Pet construct() {
            return builder.createPet();
        }

    }
}
```



简化写法

```java
package com.yiwyn.builder;

import lombok.Builder;
import lombok.Data;

import java.io.Serializable;

public class BuilderDemo {

    public static void main(String[] args) {
        User build = User.builder().age(20).build();
        System.out.println(build);
    }


    @Data
    @Builder
    static class User implements Serializable {
        private static final long serialVersionUID = -8151220194407102350L;
        private String name;
        private Integer age;
    }
}


// lombok 编译后


//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package com.yiwyn.builder;

import java.io.Serializable;

public class BuilderDemo {
    public BuilderDemo() {
    }

    public static void main(String[] args) {
        User build = BuilderDemo.User.builder().age(20).build();
        System.out.println(build);
    }

    static class User implements Serializable {
        private static final long serialVersionUID = -8151220194407102350L;
        private String name;
        private Integer age;

        User(String name, Integer age) {
            this.name = name;
            this.age = age;
        }

        public static UserBuilder builder() {
            return new UserBuilder();
        }

        public String getName() {
            return this.name;
        }

        public Integer getAge() {
            return this.age;
        }

        public void setName(String name) {
            this.name = name;
        }

        public void setAge(Integer age) {
            this.age = age;
        }

        public boolean equals(Object o) {
            if (o == this) {
                return true;
            } else if (!(o instanceof User)) {
                return false;
            } else {
                User other = (User)o;
                if (!other.canEqual(this)) {
                    return false;
                } else {
                    Object this$age = this.getAge();
                    Object other$age = other.getAge();
                    if (this$age == null) {
                        if (other$age != null) {
                            return false;
                        }
                    } else if (!this$age.equals(other$age)) {
                        return false;
                    }

                    Object this$name = this.getName();
                    Object other$name = other.getName();
                    if (this$name == null) {
                        if (other$name != null) {
                            return false;
                        }
                    } else if (!this$name.equals(other$name)) {
                        return false;
                    }

                    return true;
                }
            }
        }

        protected boolean canEqual(Object other) {
            return other instanceof User;
        }

        public int hashCode() {
            int PRIME = 59;
            int result = 1;
            Object $age = this.getAge();
            result = result * 59 + ($age == null ? 43 : $age.hashCode());
            Object $name = this.getName();
            result = result * 59 + ($name == null ? 43 : $name.hashCode());
            return result;
        }

        public String toString() {
            return "BuilderDemo.User(name=" + this.getName() + ", age=" + this.getAge() + ")";
        }

        public static class UserBuilder {
            private String name;
            private Integer age;

            UserBuilder() {
            }

            public UserBuilder name(String name) {
                this.name = name;
                return this;
            }

            public UserBuilder age(Integer age) {
                this.age = age;
                return this;
            }

            public User build() {
                return new User(this.name, this.age);
            }

            public String toString() {
                return "BuilderDemo.User.UserBuilder(name=" + this.name + ", age=" + this.age + ")";
            }
        }
    }
}


```

